import re
import json
import os
from agent import Agent
from langchain_core.messages import HumanMessage

class SWEVerifierAgent(Agent):
    def __init__(self, model, tools):
        prompt = """You are a code verification agent tasked with reviewing and fixing React/Next.js code generated by another AI. 
        Analyze the code for any syntax errors, type errors, logical errors, or deviations from React/Next.js best practices. 
        Ensure that the code can be executed without errors. Pay close attention to proper syntax, variable usage, and function calls.
        
        Return ONLY the fixed code without any explanation, JSON formatting, or markdown. The output should be ready to use directly as a Next.js component. 
        
        Some guidelines to follow: 

        1. Get rid of any placeholders. Anything that even mentions placeholder must be properly deleted (e.g. comments, img tags, text). 
        2. Ensure proper imports for React components and hooks (especially useRouter). 
           There should not be any duplications unless necessary.
        3. Ensure proper directives.
        4. For any $ used within string interpolation, make sure the string is enclosed in backticks (`).
        5. Make sure all API calls use the correct endpoint format.
        6. Ensure all event handlers are properly defined and used.
        7. Verify that state management is implemented correctly.

        Additionally, make sure there's a back button to the SWE model at the end of the component, implemented like this:

           <div className="flex justify-center mt-8 mb-8">
             <button 
                 className="btn btn-secondary" 
                 onClick={() => router.push("/swe")}
             >
                 Back to SWE Agent
             </button>
           </div>
        
        Make sure that router is defined and that it always pushes to /swe.

        For API calls related to context-aware page generation, ensure they are properly structured like this:

        const handleButtonClick = async (buttonName) => {
          setLoading(true);
          setError(null);

          try {
            const res = await fetch('/api/swe_model', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ 
                action: 'navigate',
                buttonName: buttonName,
                formData: formData  // Include form data if relevant
              }),
            });

            if (!res.ok) {
              throw new Error('Failed to submit request');
            }

            // Handle response - no need to store as we're replacing the current page
          } catch (err) {
            setError(err.message);
          } finally {
            setLoading(false);
          }
        };

        The action should always be navigate if the fetch is to /api/swe_model.

        Furthermore, if you see anything remotely similar to onClick={() => function(something${variable})} where the backticks
        are missing for the template literal, ensure you add the backticks so the code works without error so it looks like 
        onClick={() => function(`something${variable}`)}.
        """
        super().__init__(model, tools, prompt)
    
    def run(self, inputCode):
        cleanedCode = self.initialCleanup(inputCode)
        cleanedCode = self.fixCommonTemplateLiteralIssues(cleanedCode)
        result = super().run(cleanedCode)
        fixedCode = result['messages'][-1].content
        fixedCode = self.finalCleanup(fixedCode)
        self.last_message = fixedCode
        return fixedCode
    
    def initialCleanup(self, code):
        # Remove markdown code blocks
        code = re.sub(r'```(?:jsx|javascript|js|react|typescript|ts)?\n', '', code)
        code = re.sub(r'```', '', code)
        code = re.sub(r'`', '', code)
        return code.strip()
    
    def finalCleanup(self, code):
        # Remove any remaining markdown code blocks
        code = re.sub(r'```(?:jsx|javascript|js|react|typescript|ts)?\n', '', code)
        code = re.sub(r'```', '', code)
        code = re.sub(r'`', '', code)
        
        # Preserve "use client" directive if it exists
        useClientDirective = ""
        useClientMatch = re.search(r'^\s*[\'"]use client[\'"]', code)
        if useClientMatch:
            useClientDirective = code[:useClientMatch.end()] + "\n\n"
            code = code[useClientMatch.end():].strip()
        
        # Remove any explanatory text before the actual code
        importMatch = re.search(r'import\s+React|import\s+\{.*\}\s+from\s+[\'"]react[\'"]|import\s+.*\s+from\s+[\'"]next', code)
        if importMatch:
            code = code[importMatch.start():]
        
        # Restore the "use client" directive
        code = useClientDirective + code
        return code.strip()
    
    def fixCommonTemplateLiteralIssues(self, code):
        # Fix missing backticks in className assignments with template literals
        # Pattern: className={...} with ${...} inside but missing backticks
        code = self.fixClassNameTemplates(code)
        
        # Fix missing backticks in onClick handlers with template literals
        # Pattern: onClick={() => someFunction(identifier_${variable})}
        code = self.fixOnClickTemplates(code)
        
        # Fix general template literal issues
        code = self.fixGeneralTemplates(code)
        
        return code
    
    def fixClassNameTemplates(self, code):
        # Fix className={"text " + condition ? "class1" : "class2"}
        # Fix className={badge ${task.status === 'Completed' ? 'bg-success' : 'bg-secondary'}}
        pattern = re.compile(r'(className=\{[^{}]*?)((?:\w+\s+)?\${[^}]+?}[^{}]*?)(\})')
        
        def replace_class_template(match):
            prefix = match.group(1)
            template_part = match.group(2)
            suffix = match.group(3)
            
            # If there are no backticks and there's a template literal
            if '`' not in template_part and '${' in template_part:
                return f'{prefix}`{template_part}`{suffix}'
            return match.group(0)
        
        return re.sub(pattern, replace_class_template, code)
    
    def fixOnClickTemplates(self, code):
        # Fix onClick={() => handleNavigation(viewCarDetails_${car.id})}
        # This pattern specifically targets the underscore followed by ${...} pattern
        pattern = re.compile(r'(onClick=\{[^}]*?\([^(]*?)(\w+_\${[^}]+?})([^}]*?\))')
        
        def replace_onclick_template(match):
            prefix = match.group(1)
            template_part = match.group(2)
            suffix = match.group(3)
            
            # If there are no backticks and there's a template literal
            if '`' not in template_part and '${' in template_part:
                return f'{prefix}`{template_part}`{suffix}'
            return match.group(0)
        
        return re.sub(pattern, replace_onclick_template, code)
    
    def fixGeneralTemplates(self, code):
        # Find any string pattern that contains ${...} but no backticks
        # This is more risky, so we apply it with care
        pattern = re.compile(r'(["\'])([^"\'\`]*\${[^}]+}[^"\'\`]*)(["\'])')
        
        def replace_general_template(match):
            quote = match.group(1)
            content = match.group(2)
            end_quote = match.group(3)
            
            # Only replace if it's a template literal missing backticks
            if '${' in content and '`' not in content:
                return f'`{content}`'
            return match.group(0)
        
        return re.sub(pattern, replace_general_template, code)