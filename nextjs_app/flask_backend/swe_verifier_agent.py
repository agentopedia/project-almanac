import re
import json
import os
from agent import Agent
from langchain_core.messages import HumanMessage

class SWEVerifierAgent(Agent):
    def __init__(self, model, tools):
        prompt = """You are a code verification agent tasked with reviewing and fixing React/Next.js code generated by another AI. 
        Analyze the code for any syntax errors, type errors, logical errors, or deviations from React/Next.js best practices. 
        Ensure that the code can be executed without errors. Pay close attention to proper syntax, variable usage, and function calls.
        
        Return ONLY the fixed code without any explanation, JSON formatting, or markdown. The output should be ready to use directly as a Next.js component. 
        
        Some guidelines to follow: 

        1. Get rid of any placeholders. Anything that even mentions placeholder must be properly deleted (e.g. comments, img tags, text). 
        2. Ensure proper imports for React components and hooks (especially useRouter). 
           There should not be any duplications unless necessary.
        3. Ensure proper directives (like 'use client').
        4. For any $ used within string interpolation, make sure the string is enclosed in backticks (`). THIS IS CRITICAL. Check attributes, function calls, Error constructors, and style tags.
        5. Make sure all API calls use the correct endpoint format as specified.
        6. Ensure all event handlers are properly defined and used.
        7. Verify that state management is implemented correctly.
        8. Ensure there are no non-ASCII characters in the application.
        9. Define all the parameters. No parameter should implicitly be of type "any".

        Additionally, make sure there's a back button to the SWE model at the end of the component, implemented like this:

           <div className="flex justify-center mt-8 mb-8">
             <button 
                 className="btn btn-secondary" 
                 onClick={() => router.push("/swe")}
             >
                 Back to SWE Agent
             </button>
           </div>
        
        Make sure that router is defined (import { useRouter } from 'next/navigation'; const router = useRouter();) and that it always pushes to /swe.

        For API calls related to context-aware page generation, ensure they are properly structured like this:

        const handleButtonClick = async (buttonName: string) => { // Ensure parameter type
          setLoading(true);
          setError(null);

          try {
            const res = await fetch('/api/swe_model', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ 
                action: 'navigate',
                buttonName: buttonName,
                formData: formData  // Include form data if relevant, ensure formData is defined
              }),
            });

            if (!res.ok) {
              // Use backticks for template literal in Error!
              throw new Error(`Failed to submit request: ${res.status} ${res.statusText}`); 
            }

            // Handle response - no need to store as we're replacing the current page
          } catch (err: any) { // Define error type if possible, else use any
            setError(err.message);
          } finally {
            setLoading(false);
          }
        };

        The action should always be navigate if the fetch is to /api/swe_model.

        Furthermore, if you see anything remotely similar to onClick={() => function(something_${variable})} where the backticks
        are missing for the template literal, ensure you add the backticks so the code works without error so it looks like 
        onClick={() => function(`something_${variable}`)}. Pay EXTRA attention to template literals within Error constructors and style jsx tags.
        
        IMPORTANT: The code may include a CSS divider marker "--- CSS DIVIDER ---" that separates TSX code from CSS code.
        If this marker is present, preserve it exactly as is and ensure both TSX and CSS code on each side are properly fixed.
        Do not move or remove this marker in your output. Do not alter any of the CSS code on the CSS side of the divider.
        """
        super().__init__(model, tools, prompt)
    
    def run(self, inputCode):
        """Runs the verification process."""
        print("--- Verifier: Starting Run ---")
        
        # Check if the code contains a CSS divider
        has_css_divider = "--- CSS DIVIDER ---" in inputCode
        
        if has_css_divider:
            print("--- Verifier: Detected CSS Divider ---")
            # Split the code at the divider
            tsx_code, css_code = inputCode.split("--- CSS DIVIDER ---", 1)
            
            # Clean and fix both parts separately
            fixed_tsx = self.process_code_part(tsx_code)
            fixed_css = self.process_code_part(css_code, is_css=True)
            
            # Recombine with the divider preserved
            final_code = fixed_tsx + "\n\n--- CSS DIVIDER ---\n\n" + fixed_css
            self.last_message = final_code
            print("--- Verifier: Run Complete (with CSS Divider) ---")
            return final_code
        else:
            # Process as a single piece of code (original behavior)
            return self.process_code_part(inputCode)
    
    def process_code_part(self, code, is_css=False):
        """Process a single part of the code (either TSX or CSS)."""
        print(f"--- Verifier: Processing {'CSS' if is_css else 'TSX'} Part ---")
        
        cleanedCode = self.initialCleanup(code)
        
        # For CSS, just remove markdown formatting and leave it alone
        if is_css:
            print("--- Verifier: Preserving CSS code (no LLM processing) ---")
            return cleanedCode
        else:
            # Process TSX code
            cleanedCode = self.fixCommonTemplateLiteralIssues(cleanedCode)
            
            # Pass the pre-processed code to the core agent logic (simulated LLM call)
            result = super().run(cleanedCode) 
            
            # Extract the LLM's final proposed code
            llm_fixed_code = result['messages'][-1].content
            
            # Perform final cleanup on the LLM's output
            final_code = self.finalCleanup(llm_fixed_code)
            
            # Add CSS import if missing
            final_code = self.addCSSImportIfMissing(final_code)
            
            # Ensure "use client" directive is at the top
            final_code = self.ensureUseClientDirective(final_code)
        
        print(f"--- Verifier: Finished Processing {'CSS' if is_css else 'TSX'} Part ---")
        return final_code
    
    def initialCleanup(self, code):
        """Removes initial markdown formatting."""
        # Remove markdown code blocks but preserve content
        code = re.sub(r'```(?:jsx|javascript|js|react|typescript|ts|css)?\n?', '', code)
        code = re.sub(r'```', '', code)
        return code.strip()
    
    def finalCleanup(self, code):
        """Removes any remaining markdown and explanatory text before the code."""
        # Remove any remaining markdown code blocks
        code = re.sub(r'```(?:jsx|javascript|js|react|typescript|ts|css)?\n?', '', code)
        code = re.sub(r'```', '', code)
        
        # We're not preserving "use client" directive here anymore as we'll add it separately
        # with the ensureUseClientDirective method
            
        # Remove any explanatory text before the first import or component definition
        # Look for the first line that starts with 'import', 'export', 'const', 'let', 'var', 'function', 'class', or is '<' (JSX)
        codeLines = code.strip().split('\n')
        startIndex = 0
        for i, line in enumerate(codeLines):
            strippedLine = line.strip()
            if strippedLine.startswith(('import ', 'export ', 'const ', 'let ', 'var ', 'function ', 'class ', '<')) or \
               strippedLine.startswith(('@', '.', '#')) or \
               re.match(r'^\s*async\s+function', strippedLine):
                 startIndex = i
                 break
            elif not strippedLine: # Allow empty lines before code starts
                 continue
            # else: if it's some other text, we assume it's preamble to be removed
        
        code = "\n".join(codeLines[startIndex:])
        
        return code.strip()

    # ----- Template Literal Fixing Methods -----

    def fixCommonTemplateLiteralIssues(self, code):
        """Applies various fixes for missing backticks in template literals."""
        print("--- Verifier: Fixing Template Literals ---")
        code = self.fixStyleJsxTemplates(code)
        code = self.fixErrorTemplates(code)
        code = self.fixClassNameTemplates(code)
        code = self.fixOnClickTemplates(code)
        code = self.fixGeneralTemplates(code) 
        return code

    def fixStyleJsxTemplates(self, code):
        """Ensures content within <style jsx>{`...`}</style> uses backticks."""
        # Pattern to find <style jsx> or <style jsx global> tags
        pattern = re.compile(r'(<style\s+jsx(?:\s+global)?\s*>)\s*\{([^\`].*?)\}\s*(</style>)', re.DOTALL | re.IGNORECASE)

        def replace_style_content(match):
            tag_open = match.group(1)
            content = match.group(2).strip() # Get the content, strip whitespace
            tag_close = match.group(3)
            if content and not content.startswith('`') and not content.endswith('`'):
                 print(f"Fixing style jsx content: {content[:50]}...") # Debug
                 return f"{tag_open}{{`{content}`}}{tag_close}"
            elif not content:
                 return f"{tag_open}{{``}}{tag_close}" # Ensure empty styles also have backticks
            else:
                 return match.group(0) # Return original if already has backticks or is complex

        fixed_code = re.sub(pattern, replace_style_content, code)
        # Handle case where style tag might be empty {}
        fixed_code = re.sub(r'(<style\s+jsx(?:\s+global)?\s*>)\s*\{\s*\}\s*(</style>)', r'\1{``}\2', fixed_code, flags=re.IGNORECASE)
        return fixed_code


    def fixErrorTemplates(self, code):
        """Adds backticks to Error('...${...}...') calls."""
        # Pattern looks for Error(...) where the content inside has ${...} but no backticks
        # It captures the Error( part, the content, and the closing )
        # It avoids matching if the content *already* starts with `
        pattern = re.compile(r'(Error\s*\(\s*)(?!`)([^)]*?\${[^}]+?}[^)]*?)(\s*\))', re.DOTALL)

        def replace_error_template(match):
            prefix = match.group(1) # e.g., "Error("
            content = match.group(2).strip()
            suffix = match.group(3) # e.g., ")"
             # Only add backticks if not already present
            if not (content.startswith('`') and content.endswith('`')):
                print(f"Fixing Error template: Error({content[:50]}...)") # Debug
                return f"{prefix}`{content}`{suffix}"
            return match.group(0) # Return original match if already correct

        return re.sub(pattern, replace_error_template, code)

    def fixClassNameTemplates(self, code):
        """Fixes className={`...`} missing backticks."""
        # This pattern looks for className={...} where the content contains ${}
        # and is likely a string concatenation or direct template needing backticks.
        # It's tricky because valid JS expressions can be inside {}.
        # We focus on cases that look like strings mixed with ${}.
        
        # Case 1: Direct interpolation like className={badge ${...}}
        pattern1 = re.compile(r'(className=\{)(?!`)([^"}]+?\$\{[^}]+?\}[^"}]*?)(\})')
        def replace_class_template1(match):
            prefix = match.group(1)
            content = match.group(2).strip()
            suffix = match.group(3)
            # Check if it looks like a template literal missing backticks
            if '${' in content and '`' not in content and '+' not in content: # Avoid simple concatenation for now
                 print(f"Fixing className template (direct): {content[:50]}...") # Debug
                 return f'{prefix}`{content}`{suffix}'
            return match.group(0)
        code = re.sub(pattern1, replace_class_template1, code)

        # Case 2: Concatenation like className={"string " + (condition ? `${...}` : `${...}`)}
        # This is harder and potentially risky to auto-fix with regex.
        # The general template literal fixer might catch parts of this.
        # We will rely on the LLM and the general fixer for more complex cases.

        return code

    def fixOnClickTemplates(self, code):
        """Fixes onClick={() => func(`...${...}...`)} missing backticks."""
        # Pattern: onClick={...func(....)} where an argument contains ${...} but isn't quoted with backticks.
        # Matches function calls directly within the onClick handler.
        # Looks for an unquoted argument containing ${...}
        pattern = re.compile(r'(onClick=\{\s*\(?\)?\s*=>\s*\w+\s*\()([^)]*?)(?!`)([^)]*?\$\{[^}]+?\}[^)]*?)(\))')

        def replace_onclick_arg_template(match):
            prefix = match.group(1) # onClick={...func(
            args_before = match.group(2) # Arguments before the problematic one
            problem_arg = match.group(3).strip() # The argument with ${} and no backticks
            suffix = match.group(4) # ) closing the function call

            # Check if the argument seems like a template literal missing backticks
            if '${' in problem_arg and '`' not in problem_arg and not problem_arg.startswith("'") and not problem_arg.startswith('"'):
                print(f"Fixing onClick template argument: {problem_arg[:50]}...") # Debug
                # Be careful about adding commas if needed
                separator = ''
                if args_before.strip() and not args_before.strip().endswith(','):
                    separator = ', '
                return f"{prefix}{args_before}{separator}`{problem_arg}`{suffix}"
            return match.group(0) # Return original if no fix needed

        return re.sub(pattern, replace_onclick_arg_template, code)

    def fixGeneralTemplates(self, code):
        """Finds simple string literals ("..." or '...') containing ${...} and converts them to `...`."""
        # This pattern targets standard strings that accidentally contain ${}
        # It captures the opening quote (group 1), the content (group 2), and the closing quote (group 3, matching group 1)
        pattern = re.compile(r'(["\'])([^"\'\`]*?\${[^}]+?}[^"\'\`]*?)(\1)')

        def replace_general_template(match):
            quote = match.group(1) # " or '
            content = match.group(2)
            # If the captured content actually contains a template literal placeholder ${...}
            if '${' in content:
                print(f"Fixing general template: {content[:50]}...") # Debug output
                # Escape any existing backticks within the content to avoid breaking the new template literal
                content = content.replace('`', '\\`') 
                # Return the content wrapped in backticks
                return f'`{content}`'
            # If no ${} was found within this quoted string, return the original match unchanged
            return match.group(0) 

        # Apply the substitution using the pattern and the replacement function across the entire code
        return re.sub(pattern, replace_general_template, code)

    def addCSSImportIfMissing(self, code):
        """Simply adds the CSS import if it doesn't exist"""
        if 'import "./mvp.css"' in code or "import './mvp.css'" in code:
            print("--- Verifier: CSS import already exists ---")
            return code
            
        # Split the code into lines
        lines = code.split('\n')
        
        # Check if 'use client' directive exists
        has_use_client = False
        use_client_index = -1
        
        for i, line in enumerate(lines):
            if line.strip() in ['"use client"', "'use client'"]:
                has_use_client = True
                use_client_index = i
                break
        
        # Always add the CSS import as the first import
        if has_use_client:
            # Add directly after 'use client' with no empty line in between
            lines.insert(use_client_index + 1, 'import "./mvp.css";')
            print("--- Verifier: Added CSS import directly after 'use client' directive ---")
        else:
            # No 'use client' found, add at the very beginning
            lines.insert(0, 'import "./mvp.css";')
            print("--- Verifier: Added CSS import at the beginning of the file ---")
        
        return '\n'.join(lines)
        
    def ensureUseClientDirective(self, code):
        """Ensures 'use client' directive is at the top of the file"""
        lines = code.split('\n')
        
        # Check if use client directive already exists
        has_use_client = False
        for line in lines:
            if line.strip() == '"use client";' or line.strip() == "'use client';" or line.strip() == '"use client"' or line.strip() == "'use client'":
                has_use_client = True
                break
        
        if not has_use_client:
            print("--- Verifier: Adding 'use client' directive to the top of the file ---")
            lines.insert(0, '"use client";')
            
            # Add an empty line after use client for better readability
            if len(lines) > 1:
                lines.insert(1, '')
        
        return '\n'.join(lines)