import re
import json
import os
from agent import Agent
from langchain_core.messages import HumanMessage

class SWEVerifierAgent(Agent):
    def __init__(self, model, tools):
        prompt = """You are a code verification agent tasked with reviewing and fixing React/Next.js code generated by another AI. 
        Analyze the code for any syntax errors, type errors, logical errors, or deviations from React/Next.js best practices. 
        Ensure that the code can be executed without errors. Pay close attention to proper string concatenation, variable usage, and function calls.
        
        Return ONLY the fixed code without any explanation, JSON formatting, or markdown. The output should be ready to use directly as a Next.js component. 
        
        Some guidelines to follow: 

        1. Get rid of any placeholders. Anything that even mentions placeholder must be properly deleted (e.g. comments, img tags, text). 
        2. Ensure proper imports for React components and hooks (especially useRouter). 
           There should not be any duplications unless necessary.
        3. Ensure proper directives.
        4. For any $ used within string interpolation, make sure the string is enclosed in backticks (`).
        5. Make sure all API calls use the correct endpoint format.
        6. Ensure all event handlers are properly defined and used.
        7. Verify that state management is implemented correctly.

        Additionally, make sure there's a back button to the SWE model at the end of the component, implemented like this:

           <div className="flex justify-center mt-8 mb-8">
             <button 
                 className="btn btn-secondary" 
                 onClick={() => router.push("/swe")}
             >
                 Back to SWE Agent
             </button>
           </div>
        
        Make sure that router is defined and that it always pushes to /swe.

        For API calls related to context-aware page generation, ensure they are properly structured like this:

        const handleButtonClick = async (buttonName) => {
          setLoading(true);
          setError(null);

          try {
            const res = await fetch('/api/swe_model', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ 
                action: 'navigate',
                buttonName: buttonName,
                formData: formData  // Include form data if relevant
              }),
            });

            if (!res.ok) {
              throw new Error('Failed to submit request');
            }

            // Handle response - no need to store as we're replacing the current page
          } catch (err) {
            setError(err.message);
          } finally {
            setLoading(false);
          }
        };

        The action should always be navigate if the fetch is to /api/swe_model.

        If you see anything remotely similar to onClick={() => handleButtonClick(news_details_${news.id})} where the backticks
        are missing for the template literal, ensure you add the backticks so the code works without error.
        """
        super().__init__(model, tools, prompt)
    
    def run(self, inputCode):
        cleanedCode = self.initialCleanup(inputCode)
        result = super().run(cleanedCode)
        fixedCode = result['messages'][-1].content
        fixedCode = self.finalCleanup(fixedCode)
        self.last_message = fixedCode
        return fixedCode
    
    def initialCleanup(self, code):
        # Remove markdown code blocks
        code = re.sub(r'```(?:jsx|javascript|js|react|typescript|ts)?\n', '', code)
        code = re.sub(r'```', '', code)
        code = re.sub(r'`', '', code)
        return code.strip()
    
    def finalCleanup(self, code):
        # Remove any remaining markdown code blocks
        code = re.sub(r'```(?:jsx|javascript|js|react|typescript|ts)?\n', '', code)
        code = re.sub(r'```', '', code)
        code = re.sub(r'`', '', code)
        
        # Preserve "use client" directive if it exists
        useClientDirective = ""
        useClientMatch = re.search(r'^\s*[\'"]use client[\'"]', code)
        if useClientMatch:
            useClientDirective = code[:useClientMatch.end()] + "\n\n"
            code = code[useClientMatch.end():].strip()
        
        # Remove any explanatory text before the actual code
        importMatch = re.search(r'import\s+React|import\s+\{.*\}\s+from\s+[\'"]react[\'"]|import\s+.*\s+from\s+[\'"]next', code)
        if importMatch:
            code = code[importMatch.start():]
        
        # Restore the "use client" directive
        code = useClientDirective + code
        return code.strip()
    
    def fixTemplateLiterals(self, code):
        return re.sub(r'([^\s`]*\${[^}]*})', r'`\1`', code).strip()